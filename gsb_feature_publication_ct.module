<?php
/**
 * @file
 * Code for the GSB Feature Publication Content Type feature.
 */

include_once 'gsb_feature_publication_ct.features.inc';


/**
 * Implements hook_form_FORM_ID_alter() for publication node edit form.
 */
function gsb_feature_publication_ct_form_publication_node_form_alter(&$form, &$form_state) {
  $language = $form['language']['#value'];

  if (!empty($form['field_authors'][$language])) {
    foreach (element_children($form['field_authors'][$language]) as $index) {
      if (is_integer($index)) {

        $form['field_authors'][$language][$index]['field_person_fac_single_ref']['#states'] = array(
          'visible' => array(
            ':input[name="field_authors[' . $language . '][' . $index . '][field_person_fac_or_other][' . $language . ']"]' => array(
              array('value' => 'UseEntityReference'),
            ),
          ),
        );

        $form['field_authors'][$language][$index]['field_first_name']['#states'] = array(
          'visible' => array(
            ':input[name="field_authors[' . $language . '][' . $index . '][field_person_fac_or_other][' . $language . ']"]' => array(
              array('value' => 'Other'),
            ),
          ),
        );

        $form['field_authors'][$language][$index]['field_last_name']['#states'] = array(
          'visible' => array(
            ':input[name="field_authors[' . $language . '][' . $index . '][field_person_fac_or_other][' . $language . ']"]' => array(
              array('value' => 'Other'),
            ),
          ),
        );

        // remove "n/a" as an option for the fac_or_other
        unset($form['field_authors'][$language][$index]['field_person_fac_or_other'][$language]['#options']['_none']);
      }
    }
  }

  // Add required field markers. The actual field validation is done in validate callback.
  if (!empty($form['field_first_name'][$language])) {
    $form['field_first_name'][$language][0]['value']['#title'] .= " " . theme('form_required_marker');
  }

  if (!empty($form['field_last_name'][$language])) {
    $form['field_last_name'][$language][0]['value']['#title'] .= " " . theme('form_required_marker');
  }

  if (!empty($form['field_program_single'][$language])) {
    $form['field_program_single'][$language]['#title'] .= " " . theme('form_required_marker');
  }

  if (!empty($form['field_year'][$language])) {
    $form['field_year'][$language][0]['#title'] .= " " . theme('form_required_marker');
  }

  // Hide alumni fields if the alumni checkbox is not checked.
  $form['field_year']['#states']['invisible'][':input[name="field_alumni_story[' . $language . ']"]'] = array(
    array('checked' => FALSE),
  );

  $form['field_program_single']['#states']['invisible'][':input[name="field_alumni_story[' . $language . ']"]'] = array(
    array('checked' => FALSE),
  );

  if ($form['field_year_of_publication'][$language][0]['#required']) {
    $form['field_year_of_publication'][$language][0]['#title'] .= " " . theme('form_required_marker');
  }

  // Perform additional validation.
  $form['#validate'][] = 'gsb_feature_publication_ct_publication_node_form_validate';
}

/**
 *  Implements hook_field_group_pre_render_alter().
 */
function gsb_feature_publication_ct_field_group_pre_render_alter(&$element, $group, &$form) {
  // Hide field group for alumni name if alumni checkbox is not checked.
  if ($element['#id'] == 'node_publication_form_group_alumni_name') {
    $language = $form['language']['#value'];
    $element['#states']['invisible'][':input[name="field_alumni_story[' . $language . ']"]'] = array(
      array('checked' => FALSE),
    );
  }
}

/**
 * Validate callback for publication_node_form.
 *  - Conditionally validate alumni story fields.
 */
function gsb_feature_publication_ct_publication_node_form_validate($form, &$form_state) {
  $language = $form['language']['#value'];
  $values = $form_state['values'];

  // If Book is an alumni story we need to manually validate some required fields.
  if ($values['field_alumni_story'][$language][0]['value'] == TRUE) {

    // Validate first and last name.
    if (empty($values['field_first_name'][$language][0]['value'])) {
      $field_label = $form['field_first_name'][$language][0]['#title'];
      form_set_error('field_first_name][und][0][value', $field_label . ' field is required.');
    }
    if (empty($values['field_last_name'][$language][0]['value'])) {
      $field_label = $form['field_last_name'][$language][0]['#title'];
      form_set_error('field_last_name][und][0][value', $field_label . ' field is required.');
    }

    if (empty($values['field_program_single'][$language][0]['tid'])) {
      $field_label = $form['field_program_single'][$language]['#title'];
      form_set_error('field_program_single][und][0][tid', $field_label . ' field is required.');
    }

    if (empty($values['field_year'][$language][0]['value'])) {
      $field_label = $form['field_year'][$language]['#title'];
      form_set_error('field_year][und][0][value', $field_label . ' field is required.');
    }
  }
}

/**
 * Implements hook_gsb_feature_base_fields_faculty_author_types().
 */
function gsb_feature_publication_ct_gsb_feature_base_fields_faculty_author_types() {
  return array(
    'publication',
  );
}

/**
 * Implements hook_node_presave().
 */
function gsb_feature_publication_ct_node_presave($node) {

  // update the publication's academic area
  if (empty($node->nid) && $node->type == 'publication') {
    _gsb_feature_publication_ct_modify_academic_area($node);
  }
}  

/**
 * Update the publications academic area if not set with
 * the first author's academic area. 
 */
function _gsb_feature_publication_ct_update_academic_area() {

  // get list of all publications
  $query = db_select('node', 'node')
    ->fields('node')
    ->condition('type', 'publication')
    ->execute();
  $entities = $query->fetchAll();

  // loop thru the list of publications

  foreach ($entities as $info) {
    // load the publication node
    $nid = $info->nid;    
    $pub_node = node_load($nid);
    // update the publication's academic area
    _gsb_feature_publication_ct_modify_academic_area($pub_node);
    node_save($pub_node);
  }
  
}

function _gsb_feature_publication_ct_modify_academic_area(&$pub_node) {

  // check if academic area is set
  // if academic area is not set we will try to use the author's academic area

  // get the entity wrapper for the node
  $ewrap_pub = entity_metadata_wrapper('node', $pub_node);

  // get the authors info
  $authors = $ewrap_pub->field_authors->value();

  // get the first author and update the publication

  $academic_area_tids = array();

  if (!empty($authors)) {
    foreach ($authors as $author) {
      if (!empty($author->field_person_fac_single_ref['und']) && !empty($author->field_person_fac_single_ref['und'][0]['target_id'])) {

        // get author's node id
        $author_nid = $author->field_person_fac_single_ref['und'][0]['target_id'];

        // load the author node
        $author_node = node_load($author_nid);

        // update the publication with this author

        // get entity wrapper for the author node
        $ewrap_author = entity_metadata_wrapper('node', $author_node);

        // get the term for the author's academic area
        $academic_area = $ewrap_author->field_academic_area_single->value();

        if ($academic_area != null) {
          $tid = $academic_area->tid;
          $academic_area_tids[$tid] = $tid;
        }

      }
    }

    _gsb_feature_publication_ct_merge_academic_areas($pub_node, $academic_area_tids);

  }

}

function _gsb_feature_publication_ct_merge_academic_areas(&$pub_node, &$academic_area_tids) {

  if (!empty($pub_node->field_academic_area_unlimited['und'])) {
    foreach($pub_node->field_academic_area_unlimited['und'] as $key => $area) {
      $academic_area_tids[$area['tid']] = $area['tid'];
    }
    $pub_node->field_academic_area_unlimited['und'] = array();
  }

  foreach($academic_area_tids as $tid) {
    $pub_node->field_academic_area_unlimited['und'][] = array('tid' => $tid);
  }

}
